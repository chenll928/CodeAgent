# CodeGraph 功能列表和使用说明

## 项目概述

**CodeGraph** 是一个为 AI 时代设计的代码库智能分析工具，提供预处理、结构化、AI 优化的代码库智能信息。它通过 AI 原生接口实现真正的自主编码代理。

- **版本**: 0.3.0+
- **Python 要求**: 3.12+
- **许可证**: MIT
- **架构模式**: Clean Architecture（清洁架构）

---

## 核心功能

### 1. AI 原生接口 (AI-Native Interface)

#### 1.1 自主能力发现
- **功能**: AI 代理无需人工文档即可自动发现可用功能
- **实现**: 通过 `get_capabilities_manifest()` 获取自描述能力清单
- **支持的能力类型**:
  - 结构分析 (structural_analysis)
  - 语义分析 (semantic_analysis)
  - 质量分析 (quality_analysis)
  - 智能聚类 (intelligent_clustering)

#### 1.2 自然语言查询
- **功能**: AI 代理使用自然语言而非手动命令构造
- **示例查询**:
  - "查找高复杂度的文件"
  - "分析认证和授权模式"
  - "查找输入验证问题"

#### 1.3 任务感知优化
- **支持的任务类型**:
  - `bug_fixing` - 错误修复
  - `feature_development` - 功能开发
  - `code_review` - 代码审查
  - `security_audit` - 安全审计
  - `refactoring` - 重构
  - `documentation` - 文档生成
  - `testing` - 测试
  - `performance_optimization` - 性能优化
  - `dependency_analysis` - 依赖分析

#### 1.4 Token 预算管理
- **自动优化**: 根据 AI 上下文限制自动优化响应
- **预算级别**:
  - 小预算 (< 5000 tokens): 聚焦最小响应
  - 中预算 (5000-30000 tokens): 平衡分析
  - 大预算 (> 30000 tokens): 全面响应，启用聚类

#### 1.5 智能导航
- **自主探索**: AI 代理自主探索代码库
- **推荐系统**: 提供下一步操作建议
- **上下文感知**: 基于任务类型提供定制化导航

### 2. 深度代码分析

#### 2.1 符号级分析
- **提取信息**:
  - 函数、类、变量定义
  - 函数签名和参数
  - 文档字符串 (docstring)
  - 装饰器 (decorators)
  - 导出状态 (is_exported)
  - 私有标识 (is_private)
  - 行号范围 (line_start, line_end)

#### 2.2 函数级依赖追踪
- **依赖类型**:
  - `calls` - 函数调用
  - `inherits` - 继承关系
  - `imports` - 导入关系
  - `instantiates` - 实例化关系
- **追踪信息**: 包含具体行号和代码上下文

#### 2.3 语义分析
- **文件用途识别**: 自动识别文件目的（如 parsing, data_models, web_interface）
- **设计模式检测**: 识别常见设计模式（adapter, parser, model 等）
- **关键抽象提取**: 提取核心概念和抽象

#### 2.4 代码质量指标
- **复杂度评分**: 计算代码复杂度分数
- **可维护性指数**: 评估代码可维护性（0-100）
- **API 表面映射**: 区分公共接口和内部实现

### 3. 智能聚类系统

#### 3.1 聚类模式
- **analysis** (分析模式): 基于依赖关系分组，适合代码理解
- **refactoring** (重构模式): 基于功能分组，适合目标性修改
- **navigation** (导航模式): 基于大小优化，适合大型仓库探索

#### 3.2 聚类配置
- **目标大小**: 10KB / 15KB / 20KB（可配置）
- **索引级别**:
  - `basic` - 简单文件映射
  - `rich` - 完整元数据和 AI 推荐

#### 3.3 聚类输出
- **输出目录**: `.intentgraph/`（默认，建议加入 .gitignore）
- **文件结构**:
  - `index.json` - AI 导航地图
  - `domain.json` - 领域层聚类
  - `adapters.json` - 适配器层聚类
  - `application.json` - 应用层聚类
  - `utilities.json` - 工具函数聚类

### 4. 多语言支持

#### 4.1 完全支持
- **Python**:
  - 函数、类、装饰器分析
  - 复杂度计算
  - 依赖追踪
  - 文档字符串提取

#### 4.2 基础支持
- **JavaScript**: 文件级依赖
- **TypeScript**: 文件级依赖
- **Go**: 文件级依赖

#### 4.3 计划支持
- Rust
- Java
- C++

### 5. 输出级别优化

#### 5.1 Minimal（最小级别）
- **大小**: ~10KB
- **适用**: AI 代理、快速分析
- **包含**: 路径、依赖、导入、基础指标

#### 5.2 Medium（中等级别）
- **大小**: ~70KB
- **适用**: 详细 AI 任务、代码审查
- **包含**: + 关键符号、导出、可维护性分数

#### 5.3 Full（完整级别）
- **大小**: ~340KB
- **适用**: 全面审计
- **包含**: 完整分析和所有元数据

---

## 使用说明

### 安装

```bash
pip install intentgraph
```

### 基础使用

#### 2. AI 原生接口

```python
from intentgraph import connect_to_codebase

# AI 代理连接到代码库
agent = connect_to_codebase("/path/to/repo", {
    "task": "bug_fixing",
    "token_budget": 30000,
    "agent_type": "code_reviewer"
})

# 自然语言查询
results = agent.query("查找高复杂度的文件")
insights = agent.explore("security")
recommendations = agent.recommend_next_actions()
```

#### 3. 能力发现

```python
from intentgraph import get_capabilities_manifest

# 获取能力清单
capabilities = get_capabilities_manifest()

# 查看可用分析类型
analysis_types = capabilities["capabilities"]["analysis_types"]

# 查看任务优化模式
task_patterns = capabilities["agent_interaction_patterns"]["task_based_optimization"]
```

#### 4. 编程接口

```python
from intentgraph import RepositoryAnalyzer

# 创建分析器
analyzer = RepositoryAnalyzer(
    language_filter=['python'],
    include_tests=False,
    workers=4
)

# 执行分析
result = analyzer.analyze('/path/to/repo')

# 访问结果
print(f"找到 {len(result.files)} 个文件")
print(f"总复杂度: {sum(f.complexity_score for f in result.files)}")

# 遍历文件信息
for file_info in result.files:
    print(f"文件: {file_info.path}")
    print(f"复杂度: {file_info.complexity_score}")
    print(f"符号数量: {len(file_info.symbols)}")
```

### 高级用法

#### 2. 任务特定的 AI 代理

```python
# 错误修复代理
bug_agent = connect_to_codebase("/path/to/repo", {
    "task": "bug_fixing",
    "token_budget": 20000,
    "expertise_level": "expert"
})
issues = bug_agent.query("查找潜在问题区域")

# 功能开发代理
feature_agent = connect_to_codebase("/path/to/repo", {
    "task": "feature_development",
    "token_budget": 50000
})
extensions = feature_agent.query("显示新功能的扩展点")

#问题检查代理
security_agent = connect_to_codebase("/path/to/repo", {
    "task": "security_audit",
    "token_budget": 40000
})
vulnerabilities = security_agent.query("查找输入验证和数据清理问题")
```

#### 3. 自主导航

```python
agent = connect_to_codebase("/path/to/repo", {
    "task": "code_understanding",
    "token_budget": 50000
})

# 自主探索
exploration = agent.explore()

# 获取智能推荐
recommendations = agent.recommend_next_actions(exploration)

# 跟随推荐
for rec in recommendations:
    follow_up = agent.query(rec["query"])

# 检查剩余预算
remaining = agent.get_token_budget_remaining()
if remaining < 10000:
    agent.set_token_budget(remaining)
```

#### 4. 大型代码库处理

```python
# 对于超大代码库，使用聚类
agent = connect_to_codebase("/path/to/large-repo", {
    "task": "feature_development",
    "token_budget": 30000
})

# 导航到特定实现
cluster_results = agent.navigate_to_implementation("authentication")

if cluster_results["strategy"] == "cluster_navigation":
    # 获取聚类概览
    cluster_overview = cluster_results["cluster_overview"]

    # 获取 AI 推荐的聚类
    recommendations = cluster_overview["cluster_recommendations"]

    # 探索推荐的聚类
    for cluster_type, clusters in recommendations.items():
        if cluster_type == "authentication_related":
            for cluster in clusters:
                analysis = agent.query(f"分析 {cluster} 中的认证模式")
```



#### 3. 自定义 AI 框架集成

```python
class MyAIAgent:
    def __init__(self, repo_path: str):
        self.codebase = connect_to_codebase(repo_path, {
            "task": "feature_development",
            "agent_type": "custom_ai_agent"
        })

    def understand_codebase(self):
        # 自主探索
        exploration = self.codebase.explore()

        # 获取 AI 推荐
        recommendations = self.codebase.recommend_next_actions(exploration)

        # 跟随自主指导
        for rec in recommendations:
            analysis = self.codebase.query(rec["query"])

        return analysis
```

---

## 项目架构

### 架构层次

```
┌─────────────────┐
│   CLI Layer     │  ← 命令行接口
├─────────────────┤
│ Application     │  ← 分析编排
├─────────────────┤
│   Domain        │  ← 核心模型和逻辑
├─────────────────┤
│ Infrastructure  │  ← 解析器和适配器
└─────────────────┘
```

### 核心组件

#### 1. CLI 层 (`intentgraph.cli`)
- 命令行参数解析
- 日志配置和输出
- 用户反馈和进度显示
- 应用层调用编排

#### 2. 应用层 (`intentgraph.application`)
- **RepositoryAnalyzer**: 仓库扫描协调
- **ClusteringEngine**: 智能聚类引擎
- **StreamingAnalyzer**: 流式分析器
- 并行处理管理
- 依赖图构建

#### 3. 领域层 (`intentgraph.domain`)
- **核心实体**: FileInfo, Language, AnalysisResult
- **CodeSymbol**: 代码符号表示
- **FunctionDependency**: 函数级依赖
- **DependencyGraph**: 依赖图操作
- 业务规则和不变量
- 循环检测算法

#### 4. 基础设施层 (`intentgraph.adapters`)
- **Git 适配器**: .gitignore 处理
- **语言解析器**:
  - PythonParser: Python 增强解析
  - JavaScriptParser: JavaScript 解析
  - TypeScriptParser: TypeScript 解析
  - GoParser: Go 解析
- **输出格式化**: JSON 序列化和验证

#### 5. AI 接口层 (`intentgraph.ai`)
- **CodebaseAgent**: AI 原生代理接口
- **QueryBuilder**: 查询构建器
- **ResponseOptimizer**: 响应优化器
- **AutonomousNavigator**: 自主导航器
- **Manifest**: 能力清单生成

### 目录结构

```
src/intentgraph/
├── __init__.py
├── cli.py                      # CLI 入口
├── adapters/                   # 基础设施层
│   ├── file_repository.py      # 文件仓库
│   ├── git.py                  # Git 集成
│   ├── output.py               # 输出格式化
│   └── parsers/                # 语言解析器
│       ├── base.py
│       ├── python_parser.py
│       ├── enhanced_python_parser.py
│       ├── javascript_parser.py
│       ├── typescript_parser.py
│       └── go_parser.py
├── ai/                         # AI 接口层
│   ├── agent.py                # AI 代理
│   ├── manifest.py             # 能力清单
│   ├── navigation.py           # 自主导航
│   ├── query.py                # 查询构建
│   └── response.py             # 响应优化
├── application/                # 应用层
│   ├── analyzer.py             # 仓库分析器
│   ├── clustering.py           # 聚类引擎
│   ├── services.py             # 应用服务
│   └── streaming_analyzer.py  # 流式分析
└── domain/                     # 领域层
    ├── clustering.py           # 聚类模型
    ├── exceptions.py           # 领域异常
    ├── graph.py                # 依赖图
    └── models.py               # 核心模型
```

---

## 输出格式

### 分析结果结构

```json
{
  "files": [
    {
      "path": "src/models.py",
      "language": "python",
      "symbols": [
        {
          "name": "User",
          "symbol_type": "class",
          "signature": "class User(BaseModel)",
          "docstring": "用户模型类",
          "is_exported": true,
          "line_start": 10,
          "line_end": 45,
          "decorators": ["dataclass"]
        }
      ],
      "function_dependencies": [
        {
          "from_symbol": "create_user",
          "to_symbol": "User.__init__",
          "dependency_type": "instantiates",
          "line_number": 45
        }
      ],
      "file_purpose": "data_models",
      "key_abstractions": ["User", "Profile"],
      "design_patterns": ["model"],
      "complexity_score": 4,
      "maintainability_index": 82.5
    }
  ],
  "summary": {
    "total_files": 42,
    "total_functions": 156,
    "total_classes": 28,
    "total_dependencies": 89,
    "average_complexity": 3.2
  }
}
```

### 聚类索引结构

```json
{
  "clusters": [
    {
      "cluster_id": "domain",
      "name": "Domain Layer",
      "description": "核心业务逻辑和模型",
      "file_count": 5,
      "total_size_kb": 12.4,
      "primary_concerns": ["data_models", "business_rules"],
      "complexity_score": 15
    }
  ],
  "cluster_recommendations": {
    "understanding_codebase": ["domain", "application"],
    "making_changes": ["adapters", "application"],
    "finding_bugs": ["utilities", "domain"],
    "adding_features": ["application", "adapters"]
  },
  "cross_cluster_dependencies": [...],
  "file_to_cluster_map": {...}
}
```

---

## 性能基准

| 仓库大小 | 文件数 | 分析时间 | 输出大小 |
|---------|-------|---------|---------|
| 小型 (< 50 文件) | 42 | 2.3s | 180KB |
| 中型 (< 500 文件) | 287 | 12.1s | 2.1MB |
| 大型 (< 2000 文件) | 1,654 | 45.7s | 18.3MB |

*基准测试环境: MacBook Pro M2, Python 3.12*

---

## 最佳实践

### 1. 对于 AI 代理开发者

- **始终从能力发现开始**: 使用 `get_capabilities_manifest()` 了解可用功能
- **使用自然语言查询**: 优先使用自然语言而非结构化查询
- **跟随导航推荐**: 使用 `recommend_next_actions()` 获取智能建议
- **监控 Token 预算**: 定期检查 `get_token_budget_remaining()`
- **使用任务特定优化**: 为特定任务优化代理配置

### 2. 对于平台构建者

- **嵌入 IntentGraph**: 作为代码库智能的基础层
- **利用聚类功能**: 处理大型代码库
- **自定义输出级别**: 根据需求选择合适的详细程度
- **并行处理**: 使用 `--workers` 参数优化性能

### 3. 对于个人开发者

- **快速分析**: 使用 `intentgraph .` 快速了解代码库
- **技术债务评估**: 使用质量指标识别问题区域
- **重构指导**: 使用依赖分析安全重构
- **团队入职**: 生成代码库理解地图

### 4. 配置建议

```bash
# 将 .intentgraph/ 添加到 .gitignore
echo ".intentgraph/" >> .gitignore

# 对于 CI/CD 集成
intentgraph . --level minimal --format compact --output analysis.json

# 对于代码审查
intentgraph . --level medium --show-cycles

# 对于全面审计
intentgraph . --level full --include-tests --output audit.json
```

---

## 常见问题

### Q1: IntentGraph 与其他工具的区别？

**A**: IntentGraph 的独特之处在于：
- ✅ AI 原生接口（自然语言查询）
- ✅ 自主导航（自我引导）
- ✅ 任务感知优化（6 种代理类型）
- ✅ Token 预算管理（自动优化）
- ✅ 函数级依赖追踪
- ✅ 语义分析
- ✅ 智能聚类（3 种模式）




